<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tetris - TradeHax</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <link rel="stylesheet" href="../assets/enhancements.css">
    <link rel="stylesheet" href="../assets/extended-theme.css">
    <style>
        body {
            background: linear-gradient(135deg, #1a0033 0%, #2d1b69 50%, #4a148c 100%);
            min-height: 100vh;
            font-family: 'Courier New', monospace;
        }
        .game-container {
            background: rgba(0, 0, 0, 0.9);
            border: 3px solid #9c27b0;
            box-shadow: 0 0 30px rgba(156, 39, 176, 0.4);
        }
        .score-display {
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #9c27b0;
            color: #e1bee7;
            font-family: 'Courier New', monospace;
        }
        .control-panel {
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #666;
        }
        .tetris-button {
            background: linear-gradient(135deg, #4a148c 0%, #6a1b9a 100%);
            border: 2px solid #9c27b0;
            color: #e1bee7;
            font-family: 'Courier New', monospace;
            text-shadow: 0 0 5px #9c27b0;
            transition: all 0.3s ease;
        }
        .tetris-button:hover {
            background: linear-gradient(135deg, #9c27b0 0%, #ba68c8 100%);
            color: #4a148c;
            box-shadow: 0 0 15px rgba(156, 39, 176, 0.6);
        }
        canvas {
            border: 3px solid #9c27b0;
            background: #000033;
            box-shadow: 0 0 20px rgba(156, 39, 176, 0.3);
        }
        .tetris-text {
            font-family: 'Courier New', monospace;
            color: #e1bee7;
            text-shadow: 0 0 10px #9c27b0;
        }
        .next-piece {
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #666;
        }
        .tetris-grid {
            background-image:
                linear-gradient(rgba(156, 39, 176, 0.1) 1px, transparent 1px),
                linear-gradient(90deg, rgba(156, 39, 176, 0.1) 1px, transparent 1px);
        }
    </style>
</head>
<body class="text-purple-300">
    <div class="container mx-auto px-4 py-8">
        <div class="text-center mb-8">
            <h1 class="text-4xl font-bold mb-4 tetris-text">üß© TETRIS CHAMPIONSHIP</h1>
            <p class="text-xl text-gray-300 mb-4">Master the falling blocks in this enhanced Tetris experience ‚Ä¢ Earn Clover Coins</p>
            <a href="../" class="inline-block bg-gray-800 hover:bg-gray-700 text-white px-6 py-2 rounded border border-purple-500 transition-colors">‚Üê Back to Home</a>
        </div>

        <!-- Web3 Wallet & Rewards -->
        <div id="wallet-container" class="mb-8"></div>

        <div class="max-w-6xl mx-auto">
            <div class="grid grid-cols-1 lg:grid-cols-4 gap-8">
                <!-- Game Area -->
                <div class="lg:col-span-3">
                    <div class="game-container rounded-lg p-6">
                        <div class="text-center mb-4">
                            <h2 class="text-2xl font-bold tetris-text">PLAY FIELD</h2>
                        </div>
                        <div class="flex justify-center">
                            <canvas id="tetrisCanvas" width="300" height="600"></canvas>
                        </div>
                    </div>
                </div>

                <!-- Control Panel -->
                <div class="control-panel rounded-lg p-6 space-y-6">
                    <h3 class="text-xl font-bold tetris-text">GAME STATS</h3>

                    <div class="space-y-4">
                        <div class="score-display p-3 rounded">
                            <div class="text-sm opacity-75">SCORE</div>
                            <div id="score" class="text-2xl font-bold">000000</div>
                        </div>

                        <div class="score-display p-3 rounded">
                            <div class="text-sm opacity-75">LINES</div>
                            <div id="lines" class="text-2xl font-bold">000</div>
                        </div>

                        <div class="score-display p-3 rounded">
                            <div class="text-sm opacity-75">LEVEL</div>
                            <div id="level" class="text-2xl font-bold">01</div>
                        </div>

                        <div class="score-display p-3 rounded">
                            <div class="text-sm opacity-75">HIGH SCORE</div>
                            <div id="highScore" class="text-2xl font-bold">000000</div>
                        </div>
                    </div>

                    <!-- Next Piece Preview -->
                    <div class="next-piece p-4 rounded">
                        <h4 class="text-sm font-bold mb-2 tetris-text">NEXT</h4>
                        <canvas id="nextCanvas" width="80" height="80"></canvas>
                    </div>

                    <!-- Controls -->
                    <div class="space-y-3">
                        <button id="startBtn" onclick="startTetris()" class="tetris-button w-full py-3 px-4 rounded font-bold">
                            START GAME
                        </button>
                        <button onclick="pauseGame()" class="tetris-button w-full py-3 px-4 rounded font-bold">
                            PAUSE
                        </button>
                        <button onclick="resetGame()" class="tetris-button w-full py-3 px-4 rounded font-bold">
                            RESET
                        </button>
                    </div>

                    <div class="text-sm text-gray-400">
                        <h4 class="font-bold mb-2 tetris-text">CONTROLS:</h4>
                        <div class="space-y-1 text-xs">
                            <div>‚Üê‚Üí Move</div>
                            <div>‚Üì Soft Drop</div>
                            <div>‚Üë Rotate</div>
                            <div>Space: Hard Drop</div>
                            <div>C: Hold</div>
                        </div>
                    </div>

                    <div class="mt-4 text-xs text-gray-400">
                        <h4 class="font-bold mb-2 tetris-text text-purple-400">REWARDS:</h4>
                        <div class="space-y-1">
                            <div>‚Ä¢ Line clear: +1 coin</div>
                            <div>‚Ä¢ Tetris (4 lines): +10 coins</div>
                            <div>‚Ä¢ Level up: +5 coins</div>
                            <div>‚Ä¢ Perfect clear: +100 coins</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Solana Web3.js -->
    <script src="https://unpkg.com/@solana/web3.js@latest/lib/index.iife.min.js"></script>
    <script src="web3-rewards.js"></script>

    <script>
        // Initialize Web3 Rewards
        const rewardsSystem = new Web3RewardsSystem('tetris');
        rewardsSystem.initWalletUI('wallet-container');

        // Enhanced Tetris Game with modern graphics and smooth controls
        class TetrisGame {
            constructor() {
                this.canvas = document.getElementById('tetrisCanvas');
                if (!this.canvas) {
                    console.error('Tetris canvas not found!');
                    return;
                }
                this.ctx = this.canvas.getContext('2d');
                this.nextCanvas = document.getElementById('nextCanvas');
                if (!this.nextCanvas) {
                    console.error('Next piece canvas not found!');
                    return;
                }
                this.nextCtx = this.nextCanvas.getContext('2d');

                this.gridSize = 30;
                this.rows = this.canvas.height / this.gridSize;
                this.cols = this.canvas.width / this.gridSize;

                this.board = Array.from({length: this.rows}, () => Array(this.cols).fill(0));
                this.currentPiece = null;
                this.nextPiece = null;
                this.heldPiece = null;
                this.canHold = true;

                this.score = 0;
                this.lines = 0;
                this.level = 1;
                this.highScore = localStorage.getItem('tetrisHighScore') || 0;
                this.gameRunning = false;
                this.paused = false;
                this.gameLoop = null;
                this.dropTimer = 0;
                this.dropInterval = 1000;

                // Enhanced piece colors with glow effects
                this.colors = [
                    null,
                    '#ff4444', // I - Red
                    '#44ff44', // O - Green
                    '#4444ff', // T - Blue
                    '#ffff44', // S - Yellow
                    '#ff44ff', // Z - Magenta
                    '#44ffff', // J - Cyan
                    '#ff8844'  // L - Orange
                ];

                this.pieces = [
                    [], // Empty
                    [[1, 1, 1, 1]], // I
                    [[1, 1], [1, 1]], // O
                    [[0, 1, 0], [1, 1, 1]], // T
                    [[0, 1, 1], [1, 1, 0]], // S
                    [[1, 1, 0], [0, 1, 1]], // Z
                    [[1, 0, 0], [1, 1, 1]], // J
                    [[0, 0, 1], [1, 1, 1]]  // L
                ];

                this.updateDisplay();
                this.generateNewPiece();
                this.setupControls();
                this.draw();
            }

            updateDisplay() {
                document.getElementById('score').textContent = this.score.toString().padStart(6, '0');
                document.getElementById('lines').textContent = this.lines.toString().padStart(3, '0');
                document.getElementById('level').textContent = this.level.toString().padStart(2, '0');
                document.getElementById('highScore').textContent = this.highScore.toString().padStart(6, '0');
            }

            generateNewPiece() {
                if (!this.nextPiece) {
                    this.nextPiece = this.createPiece();
                }
                this.currentPiece = this.nextPiece;
                this.nextPiece = this.createPiece();
                this.currentPiece.x = Math.floor(this.cols / 2) - Math.floor(this.currentPiece.shape[0].length / 2);
                this.currentPiece.y = 0;

                if (this.collision(this.currentPiece)) {
                    this.gameOver();
                }
            }

            createPiece() {
                const type = Math.floor(Math.random() * 7) + 1;
                return {
                    shape: this.pieces[type].map(row => [...row]),
                    x: 0,
                    y: 0,
                    type: type
                };
            }

            collision(piece, dx = 0, dy = 0) {
                for (let y = 0; y < piece.shape.length; y++) {
                    for (let x = 0; x < piece.shape[y].length; x++) {
                        if (piece.shape[y][x]) {
                            const newX = piece.x + x + dx;
                            const newY = piece.y + y + dy;
                            if (newX < 0 || newX >= this.cols || newY >= this.rows || (newY >= 0 && this.board[newY][newX])) {
                                return true;
                            }
                        }
                    }
                }
                return false;
            }

            mergePiece() {
                for (let y = 0; y < this.currentPiece.shape.length; y++) {
                    for (let x = 0; x < this.currentPiece.shape[y].length; x++) {
                        if (this.currentPiece.shape[y][x]) {
                            this.board[this.currentPiece.y + y][this.currentPiece.x + x] = this.currentPiece.type;
                        }
                    }
                }
            }

            clearLines() {
                let linesCleared = 0;
                for (let y = this.rows - 1; y >= 0; y--) {
                    if (this.board[y].every(cell => cell)) {
                        this.board.splice(y, 1);
                        this.board.unshift(Array(this.cols).fill(0));
                        linesCleared++;
                        y++;
                    }
                }

                if (linesCleared > 0) {
                    this.lines += linesCleared;
                    
                    // Award coins for lines
                    if (linesCleared === 4) {
                        // Tetris bonus!
                        rewardsSystem.awardCoins(10, 'Tetris: 4 lines cleared!');
                    } else {
                        rewardsSystem.awardCoins(linesCleared, `Tetris: ${linesCleared} line(s) cleared`);
                    }
                    
                    // Score based on lines cleared and level
                    const basePoints = [0, 40, 100, 300, 1200];
                    this.score += basePoints[linesCleared] * this.level;

                    // Level up every 10 lines
                    const previousLevel = this.level;
                    this.level = Math.floor(this.lines / 10) + 1;
                    this.dropInterval = Math.max(50, 1000 - (this.level * 50));
                    
                    if (this.level > previousLevel) {
                        rewardsSystem.awardForLevelUp('tetris', this.level);
                    }

                    // High score check with reward
                    if (this.score > this.highScore) {
                        const wasNewHighScore = this.highScore > 0;
                        this.highScore = this.score;
                        localStorage.setItem('tetrisHighScore', this.highScore);
                        if (wasNewHighScore) {
                            rewardsSystem.awardForHighScore('tetris');
                        }
                    }
                    
                    // Check for perfect clear
                    if (this.board.every(row => row.every(cell => cell === 0))) {
                        rewardsSystem.awardCoins(100, 'Tetris: Perfect Clear!');
                    }
                }
            }

            rotate(piece) {
                const rotated = piece.shape[0].map((_, i) =>
                    piece.shape.map(row => row[i]).reverse()
                );
                return rotated;
            }

            holdPiece() {
                if (!this.canHold) return;

                if (this.heldPiece) {
                    [this.currentPiece, this.heldPiece] = [this.heldPiece, this.currentPiece];
                    this.currentPiece.x = Math.floor(this.cols / 2) - Math.floor(this.currentPiece.shape[0].length / 2);
                    this.currentPiece.y = 0;
                } else {
                    this.heldPiece = this.currentPiece;
                    this.generateNewPiece();
                }
                this.canHold = false;
            }

            draw() {
                // Clear main canvas
                this.ctx.fillStyle = '#000033';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                // Draw grid
                this.ctx.strokeStyle = 'rgba(156, 39, 176, 0.2)';
                this.ctx.lineWidth = 1;
                for (let x = 0; x <= this.cols; x++) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(x * this.gridSize, 0);
                    this.ctx.lineTo(x * this.gridSize, this.canvas.height);
                    this.ctx.stroke();
                }
                for (let y = 0; y <= this.rows; y++) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, y * this.gridSize);
                    this.ctx.lineTo(this.canvas.width, y * this.gridSize);
                    this.ctx.stroke();
                }

                // Draw placed pieces
                for (let y = 0; y < this.rows; y++) {
                    for (let x = 0; x < this.cols; x++) {
                        if (this.board[y][x]) {
                            this.drawBlock(this.ctx, x, y, this.colors[this.board[y][x]]);
                        }
                    }
                }

                // Draw current piece
                if (this.currentPiece) {
                    for (let y = 0; y < this.currentPiece.shape.length; y++) {
                        for (let x = 0; x < this.currentPiece.shape[y].length; x++) {
                            if (this.currentPiece.shape[y][x]) {
                                this.drawBlock(this.ctx, this.currentPiece.x + x, this.currentPiece.y + y, this.colors[this.currentPiece.type]);
                            }
                        }
                    }
                }

                // Draw next piece
                this.nextCtx.fillStyle = '#000033';
                this.nextCtx.fillRect(0, 0, this.nextCanvas.width, this.nextCanvas.height);

                if (this.nextPiece) {
                    const offsetX = Math.floor((this.nextCanvas.width / 20 - this.nextPiece.shape[0].length) / 2);
                    const offsetY = Math.floor((this.nextCanvas.height / 20 - this.nextPiece.shape.length) / 2);

                    for (let y = 0; y < this.nextPiece.shape.length; y++) {
                        for (let x = 0; x < this.nextPiece.shape[y].length; x++) {
                            if (this.nextPiece.shape[y][x]) {
                                this.drawBlock(this.nextCtx, offsetX + x, offsetY + y, this.colors[this.nextPiece.type], 20);
                            }
                        }
                    }
                }
            }

            drawBlock(ctx, x, y, color, size = this.gridSize) {
                const blockSize = size - 2;

                // Main block
                ctx.fillStyle = color;
                ctx.fillRect(x * size + 1, y * size + 1, blockSize, blockSize);

                // Highlight
                ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.fillRect(x * size + 1, y * size + 1, blockSize, 2);

                // Shadow
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(x * size + blockSize - 1, y * size + 1, 2, blockSize);
                ctx.fillRect(x * size + 1, y * size + blockSize - 1, blockSize, 2);
            }

            move(dx, dy) {
                if (!this.collision(this.currentPiece, dx, dy)) {
                    this.currentPiece.x += dx;
                    this.currentPiece.y += dy;
                    return true;
                }
                return false;
            }

            drop() {
                if (!this.move(0, 1)) {
                    this.mergePiece();
                    this.clearLines();
                    this.generateNewPiece();
                    this.canHold = true;
                }
            }

            hardDrop() {
                while (this.move(0, 1)) {}
                this.drop();
            }

            rotatePiece() {
                const rotated = this.rotate(this.currentPiece);
                const originalShape = this.currentPiece.shape;
                this.currentPiece.shape = rotated;

                if (this.collision(this.currentPiece)) {
                    // Try wall kicks
                    if (!this.collision(this.currentPiece, 1, 0)) {
                        this.currentPiece.x += 1;
                    } else if (!this.collision(this.currentPiece, -1, 0)) {
                        this.currentPiece.x -= 1;
                    } else if (!this.collision(this.currentPiece, 0, -1)) {
                        this.currentPiece.y -= 1;
                    } else {
                        this.currentPiece.shape = originalShape;
                    }
                }
            }

            update() {
                if (!this.gameRunning || this.paused) return;

                this.dropTimer += 16; // ~60fps
                if (this.dropTimer >= this.dropInterval) {
                    this.drop();
                    this.dropTimer = 0;
                }

                this.draw();
            }

            start() {
                if (this.gameRunning) return;

                this.gameRunning = true;
                this.paused = false;
                rewardsSystem.resetSession();
                document.getElementById('startBtn').textContent = 'RESTART';

                this.gameLoop = setInterval(() => this.update(), 16);
            }

            pause() {
                this.paused = !this.paused;
            }

            reset() {
                this.board = Array.from({length: this.rows}, () => Array(this.cols).fill(0));
                this.currentPiece = null;
                this.nextPiece = null;
                this.heldPiece = null;
                this.canHold = true;
                this.score = 0;
                this.lines = 0;
                this.level = 1;
                this.gameRunning = false;
                this.paused = false;
                this.dropInterval = 1000;
                clearInterval(this.gameLoop);

                document.getElementById('startBtn').textContent = 'START GAME';
                this.generateNewPiece();
                this.draw();
                this.updateDisplay();
            }

            gameOver() {
                this.gameRunning = false;
                clearInterval(this.gameLoop);
                alert(`Game Over!\nScore: ${this.score}\nLines: ${this.lines}\nLevel: ${this.level}`);
                this.reset();
            }

            setupControls() {
                document.addEventListener('keydown', (e) => {
                    if (!this.gameRunning || this.paused) return;

                    switch (e.key.toLowerCase()) {
                        case 'arrowleft':
                        case 'a':
                            e.preventDefault();
                            this.move(-1, 0);
                            break;
                        case 'arrowright':
                        case 'd':
                            e.preventDefault();
                            this.move(1, 0);
                            break;
                        case 'arrowdown':
                        case 's':
                            e.preventDefault();
                            this.move(0, 1);
                            break;
                        case 'arrowup':
                        case 'w':
                            e.preventDefault();
                            this.rotatePiece();
                            break;
                        case ' ':
                            e.preventDefault();
                            this.hardDrop();
                            break;
                        case 'c':
                            e.preventDefault();
                            this.holdPiece();
                            break;
                    }
                });
            }
        }

        const game = new TetrisGame();

        function startTetris() {
            rewardsSystem.resetSessionCoins();
            game.start();
        }

        function pauseGame() {
            game.pause();
        }

        function resetGame() {
            game.reset();
        }
    </script>
    <script src="../theme-extensions.js"></script>
</body>
</html>
